// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.splitLabelToCommands = splitLabelToCommands;
exports.strip = strip;
exports.containIncludeCommand = containIncludeCommand;
exports.parseValue = parseValue;
exports.parseVariablesFromLabel = parseVariablesFromLabel;
exports.generateEmbedCode = generateEmbedCode;
exports.getContent = getContent;
exports.embedCode = embedCode;
exports.parse = parse;

var _options = require("./options.js");

var _unescapeString = require("./unescape-string.js");

var _languageDetection = require("./language-detection");

var _marker = require("./marker");

var _slicer = require("./slicer");

var _title = require("./title");

var _template = require("./template");

var _backtickMaker = require("./backtick-maker");

var path = require("path");
var Handlebars = require("handlebars");
var logger = require("winston-color");


var markdownLinkFormatRegExp = /\[(?=((?:[^\]]|\\.)*))\1\]\((?=((?:[^\)]|\\.)*))\2\)/gm;

var keyEx = "\\w+";
var kvsepEx = "[:=]";
var spacesEx = "\\s*";
var quoteEx = "[\"']";
var valEx = "(?:[^'\"\\\\]|\\\\.)*";
var argEx = "" + quoteEx + valEx + quoteEx + "|true|false";
var expressionEx = "(" + keyEx + ")" + kvsepEx + spacesEx + "(" + argEx + ")";
var expressionRegExp = new RegExp(expressionEx, "g");

var markerRegExp = /^\s*(([-\w\s]*,?)*)$/;

/**
 * A counter to count how many code are imported.
 */
var codeCounter = function () {
    var count = 0;
    return function () {
        return count++;
    }; // Return and increment
}();

/**
 * split label to commands
 * @param {string} label
 * @returns {Array}
 */
function splitLabelToCommands() {
    var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

    var result = label.split(/(:|[,\s])/);
    if (!result) {
        return [];
    }
    // remove null command
    return result.map(function (command) {
        return command.trim();
    }).filter(function (command) {
        return command.length > 0;
    });
}

/**
 * Unindent code
 * @param {string} s
 * @return {string}
 */
function strip(s) {
    // inspired from https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/string/strip.rb
    if (s === undefined || s === "") {
        return s;
    }
    var indents = s.split(/\n/).map(function (s) {
        return s.match(/^[ \t]*(?=\S)/);
    }).filter(function (m) {
        return m;
    }).map(function (m) {
        return m[0];
    });
    var smallestIndent = indents.sort(function (a, b) {
        return a.length - b.length;
    })[0];
    return s.replace(new RegExp("^" + smallestIndent, "gm"), "");
}

/**
 * if contain "include" or "import" command, then return true
 * @param {Array} commands
 * @returns {boolean}
 */
function containIncludeCommand() {
    var commands = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var reg = /^(include|import)$/;
    return commands.length > 0 ? reg.test(commands[0].trim()) : false;
}

/**
 * Parse the given value to the given type. Returns the value if valid, otherwise returns undefined.
 * @param {string} value
 * @param {string} type "string", "boolean"
 * @param {string} key
 * @return {boolean|string|undefined}
 */
function parseValue(value, type, key) {
    if (type === "string") {
        var unescapedvalue = (0, _unescapeString.unescapeString)(value.substring(1, value.length - 1));
        if (key === "marker" && !markerRegExp.test(unescapedvalue)) {
            logger.error("include-codeblock: parseVariablesFromLabel: invalid value " + ("`" + unescapedvalue + "` in key `marker`"));
            return undefined;
        }
        return unescapedvalue;
    }

    if (type === "boolean") {
        if (["true", '"true"', "'true'"].indexOf(value) >= 0) {
            return true;
        }

        if (["false", '"false"', "'false'"].indexOf(value) >= 0) {
            return false;
        }

        logger.error("include-codeblock: parseVariablesFromLabel: invalid value " + ("`" + value + "` in key `" + key + "`. Expect true or false."));
        return undefined;
    }

    logger.error("include-codeblock: parseVariablesFromLabel: unknown key type `" + type + "` (see options.js)");
    return undefined;
}

/** Parse the command label and return a new key-value object
 * @example
 *      [import,title:"<thetitle>",label:"<thelabel>"](path/to/file.ext)
 * @param {object} kvMap
 * @param {string} label
 * @return {object}
 */
function parseVariablesFromLabel(kvMap, label) {
    var kv = Object.assign({}, kvMap);

    var match = "";
    while (match = expressionRegExp.exec(label)) {
        var key = match[1];
        if (key === "include" || key === "import") {
            key = "marker";
        }
        var value = match[2];

        if (!kv.hasOwnProperty(key)) {
            logger.error("include-codeblock: parseVariablesFromLabel: unknown key " + ("`" + key + "` (see options.js)"));
            return;
        }

        var parsedValue = parseValue(value, _typeof(_options.defaultKeyValueMap[key]), key);
        if (parsedValue !== undefined) {
            kv[key] = parsedValue;
        }
    }

    return Object.freeze(kv);
}

/**
 * generate code from options
 * @param {object} kvMap
 * @param {string} fileName
 * @param {string} originalPath
 * @param {string} content
 * @param {string} backtick
 * @return {string}
 */
function generateEmbedCode(kvMap, _ref) {
    var fileName = _ref.fileName,
        originalPath = _ref.originalPath,
        content = _ref.content,
        backtick = _ref.backtick;

    var tContent = (0, _template.getTemplateContent)(kvMap);
    var kv = Object.assign({}, kvMap);
    var count = (0, _title.hasTitle)(kv) ? codeCounter() : -1;
    (0, _options.checkMapTypes)(kvMap, "generatedEmbedCode");
    var contextMap = Object.assign({}, kvMap, {
        content: content,
        count: count,
        fileName: fileName,
        originalPath: originalPath,
        backtick: backtick
    });
    // compile template
    var handlebars = Handlebars.compile(tContent);
    // compile with data.
    return handlebars(contextMap);
}

/**
 * return content from file or url.
 * @param {string} filePath it should be absolute path
 * @return {string}
 */
function getContent(filePath) {
    return (0, _template.readFileFromPath)(filePath);
}

/**
 * generate code with options
 * @param {object} kvMap
 * @param {string} filePath
 * @param {string} originalPath
 * @param {string} label
 * @return {string}
 */
function embedCode(kvMap, _ref2) {
    var filePath = _ref2.filePath,
        originalPath = _ref2.originalPath,
        label = _ref2.label;

    var code = getContent(filePath);
    var fileName = path.basename(filePath);
    var kvmparsed = parseVariablesFromLabel(kvMap, label);
    var kvm = (0, _languageDetection.getLang)(kvmparsed, originalPath);
    var unindent = kvm.unindent;

    var content = code;
    // Slice content via line numbers.
    if ((0, _slicer.hasSliceRange)(label)) {
        var _getSliceRange = (0, _slicer.getSliceRange)(label),
            _getSliceRange2 = _slicedToArray(_getSliceRange, 2),
            start = _getSliceRange2[0],
            end = _getSliceRange2[1];

        content = (0, _slicer.sliceCode)(code, start, end, unindent);
    } else if ((0, _marker.hasMarker)(kvm)) {
        // Slice content via markers.
        var marker = (0, _marker.getMarker)(kvm);
        content = (0, _marker.removeMarkers)((0, _marker.markerSliceCode)(code, marker));
    }
    if (unindent === true) {
        content = strip(content);
    }

    var backtick = (0, _backtickMaker.codeBlockBacktick)(content);
    return generateEmbedCode(kvm, { fileName: fileName, originalPath: originalPath, content: content, backtick: backtick });
}

/**
 * Parse command using options from pluginConfig.
 * @param {string} content
 * @param {string} baseDir
 * @param {{template?: string}} options
 * @return {Array}
 */
function parse(content, baseDir) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var results = [];
    var kvMap = (0, _options.initOptions)(options);
    var res = true;
    while (res = markdownLinkFormatRegExp.exec(content)) {
        var _res = res,
            _res2 = _slicedToArray(_res, 3),
            all = _res2[0],
            label = _res2[1],
            originalPath = _res2[2];

        var commands = splitLabelToCommands(label);
        if (containIncludeCommand(commands)) {
            var absolutePath = path.resolve(baseDir, originalPath);
            var replacedContent = embedCode(kvMap, {
                filePath: absolutePath,
                originalPath: originalPath,
                label: label
            });
            results.push({
                target: all,
                replaced: replacedContent
            });
        }
    }
    return results;
}
//# sourceMappingURL=parser.js.map