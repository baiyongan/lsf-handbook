// LICENSE : MIT
"use strict";
/*
 format: [import:<start-lineNumber>-<end-lineNumber>](path/to/file)
 lineNumber start with 1.

 Patterns:

 All: [import, hello-world.js](../src/hello-world.js)
 1-2: [import:1-2, hello-world.js](../src/hello-world.js)
 2-3: [import:2-3, hello-world.js](../src/hello-world.js)
 2>=: [import:2-, hello-world.js](../src/hello-world.js)
 <=3: [import:-3, hello-world.js](../src/hello-world.js)
 */
/**
 * get range from label
 * @param {string} label
 * @returns {number[]}
 */

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.getSliceRange = getSliceRange;
exports.hasSliceRange = hasSliceRange;
exports.sliceCode = sliceCode;
function getSliceRange(label) {
    var regExp = /^(?:include|import):(\d*)-(\d*)[,\s]?.*$/;
    var matches = regExp.exec(label);
    if (matches === null) {
        return [];
    }
    // return [undefined, undefined] if not matched, else contains [all,start,end].

    var _matches$slice = matches.slice(1, 3),
        _matches$slice2 = _slicedToArray(_matches$slice, 2),
        start = _matches$slice2[0],
        end = _matches$slice2[1];

    var startOrUndefined = start !== "" ? parseInt(start, 10) : undefined;
    var endOrUndefined = end !== "" ? parseInt(end, 10) : undefined;
    return [startOrUndefined, endOrUndefined];
}

/**
 * has range command in the label
 * @param {string} label
 * @returns {boolean}
 */
function hasSliceRange(label) {
    var range = getSliceRange(label);

    var _range = _slicedToArray(range, 2),
        start = _range[0],
        end = _range[1];

    return start !== undefined || end !== undefined;
}

/**
 * slice {@link code} with {@link start} and {@link end}
 * @param {string} code
 * @param {number|undefined} [start]
 * @param {number|undefined} [end]
 * @param {boolean|undefined} [untrimmed]
 * @returns {string}
 */
function sliceCode(code, start, end, untrimmed) {
    if (start === undefined && end === undefined) {
        return code;
    }
    var slitted = code.split("\n");
    if (start === undefined) {
        start = 1;
    }
    if (end === undefined) {
        end = slitted.length;
    }
    var sliced = slitted.slice(start - 1, end).join("\n");
    return untrimmed ? sliced : sliced.trim();
}
//# sourceMappingURL=slicer.js.map