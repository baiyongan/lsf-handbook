// LICENSE : MIT
/*
 * Feature: doxygen like snippet code.
 * For code source documenting, see
 * https://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmdsnippet
 *
 * Gibook usage:
 *
 *      [import:<markername>](path/to/file)
 *
 * NB: markername must begin with a letter to avoid conflict with slice
 *     line range.
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getMarker = getMarker;
exports.hasMarker = hasMarker;
exports.markerSliceCode = markerSliceCode;
exports.replaceAll = replaceAll;
exports.removeMarkers = removeMarkers;
var logger = require("winston-color");
var commentOpen = "(/+/+|#|%|/\\*|<!--)";
var commentClose = "(\\*/|-->)?";
var doxChar = "[*!/#]"; // doxygen documentation character
var spaces = "[ \t]*"; // h spaces
var spacesAny = "\\s*"; // h+v spaces
var markerNameFormat = "(\\s*[a-zA-Z][\\w\\s]*)"; // Must contain a char.

/*
 * format: [import:<markername>](path/to/file)
 * @param {Object} keyValObject
 * @return {string}
 */
function getMarker(keyValObject) {
    return keyValObject.marker;
}

/**
 * format: [import:<markername>](path/to/file)
 * check if the import filled has a markername.
 * @example:
 *      hasMarker(label)
 * @param {Object} keyValObject
 * @returns {boolean}
 */
function hasMarker(keyValObject) {
    var marker = getMarker(keyValObject);
    return marker !== undefined && marker !== "";
}

/* Parse the code from given markers
 *
 * see test/marker-test.js
 */
/**
 * get sliced code by {@link markername}
 * @param {string} code
 * @param {string} markers
 * @returns {string}
 */
function markerSliceCode(code, markers) {
    if (markers === undefined || markers === "") {
        return code;
    }
    var parsedcode = "";
    var markerlist = markers.split(",");

    var i = 0;
    // regex
    markerlist.forEach(function (marker) {
        var balise = "\\[" + marker + "\\]";
        var pattern = "\\n" + spacesAny + commentOpen + doxChar + spaces + balise + spaces + commentClose + spaces;

        var regstr = pattern + "\\n*([\\s\\S]*)" + pattern;
        var reg = new RegExp(regstr);
        var res = code.match(reg);

        if (res) {
            parsedcode += res[3]; // count parenthesis in pattern.
        } else {
            logger.warn("markersSliceCode(): marker `" + marker + "` not found");
            parsedcode += "Error: marker `" + marker + "` not found";
        }
        if (markerlist.length > 0 && i < markerlist.length - 1) {
            parsedcode += "\n";
        }
        i++;
    });
    return parsedcode;
}

/** Replace all regex occurence by sub in the string str,
 * @param {string} str
 * @param {string} reg
 * @param {string} sub
 * @return {string}
 */
function replaceAll(str, reg, sub) {
    return str.replace(new RegExp(reg, "g"), sub);
}

/** Function that remove all markers in the given code
 * @param {string} code
 * @return {string}
 */
function removeMarkers(code) {
    // various language comment
    var tag = "\\[" + markerNameFormat + "\\]";
    var pattern = spacesAny + commentOpen + doxChar + spaces + tag + spaces + commentClose + spaces;

    return replaceAll(code, pattern, "");
}
//# sourceMappingURL=marker.js.map